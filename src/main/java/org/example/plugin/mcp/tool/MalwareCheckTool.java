package org.example.plugin.mcp.tool;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.*;
import software.coley.recaf.info.JvmClassInfo;
import software.coley.recaf.services.workspace.WorkspaceManager;
import software.coley.recaf.workspace.model.Workspace;
import software.coley.recaf.workspace.model.bundle.JvmClassBundle;

import java.util.*;

import static org.example.plugin.mcp.util.JsonUtil.*;
import static org.example.plugin.mcp.util.SchemaBuilder.*;

public final class MalwareCheckTool implements McpTool {

	private static final String ALL_CATEGORIES = "networking,file-io,reflection,runtime-exec,"
			+ "unsafe,native-interop,classloading,crypto,instrumentation,management,registry";

	private final WorkspaceManager workspaceManager;

	public MalwareCheckTool(WorkspaceManager workspaceManager) {
		this.workspaceManager = workspaceManager;
	}

	@Override
	public String name() {
		return "recaf_check_malware";
	}

	@Override
	public JsonObject schema() {
		return toolDef(name(), "Check suspicious APIs",
				"Scan the workspace for suspicious API usage patterns commonly found in "
						+ "malicious Java code. Groups findings into categories: networking, "
						+ "file-io, reflection, runtime-exec, unsafe, native-interop, "
						+ "classloading, crypto, instrumentation, management, registry.",
				object(
						prop("maxClasses", integer("Max classes to scan (default 500, max 5000)")),
						prop("categories", string("Comma-separated categories to check. "
								+ "Default: all. Options: " + ALL_CATEGORIES))
				));
	}

	@Override
	public JsonObject execute(JsonObject args) {
		if (!workspaceManager.hasCurrentWorkspace()) return error("No workspace open");
		Workspace ws = workspaceManager.getCurrent();
		JvmClassBundle bundle = ws.getPrimaryResource().getJvmClassBundle();
		if (bundle == null) return error("No JVM classes in workspace");

		int maxClasses = clamp(integer(args.get("maxClasses"), 500), 10, 5000);
		Set<String> categories = parseSet(str(args.get("categories")), ALL_CATEGORIES);
		Map<String, List<ApiPattern>> patternGroups = buildPatternGroups(categories);

		Map<String, LinkedHashSet<Finding>> grouped = new LinkedHashMap<>();
		for (String cat : patternGroups.keySet())
			grouped.put(cat, new LinkedHashSet<>());

		int scanned = 0;
		for (JvmClassInfo classInfo : bundle) {
			if (scanned >= maxClasses) break;
			scanned++;
			try {
				ClassNode node = new ClassNode();
				classInfo.getClassReader().accept(node, ClassReader.SKIP_DEBUG);
				scanClass(classInfo.getName(), node, patternGroups, grouped);
			} catch (Exception ignored) {
			}
		}

		JsonObject out = new JsonObject();
		out.addProperty("classesScanned", scanned);
		out.addProperty("totalClasses", bundle.size());

		int totalFindings = 0;
		JsonObject categoriesOut = new JsonObject();
		for (var entry : grouped.entrySet()) {
			LinkedHashSet<Finding> findings = entry.getValue();
			int count = findings.size();
			totalFindings += count;

			JsonObject catObj = new JsonObject();
			catObj.addProperty("count", count);
			catObj.addProperty("severity", count == 0 ? "none"
					: count > 20 ? "high"
					: count > 5 ? "medium" : "low");

			JsonArray details = new JsonArray();
			int shown = 0;
			for (Finding finding : findings) {
				if (shown >= 120) break;
				JsonObject d = new JsonObject();
				d.addProperty("type", finding.category());
				d.addProperty("className", finding.className());
				d.addProperty("method", finding.method());
				d.addProperty("matchKind", finding.kind());
				d.addProperty("matched", finding.matched());
				details.add(d);
				shown++;
			}
			catObj.add("details", details);
			categoriesOut.add(entry.getKey(), catObj);
		}

		out.addProperty("totalFindings", totalFindings);
		out.add("categories", categoriesOut);
		return out;
	}

	private void scanClass(String className, ClassNode node,
	                        Map<String, List<ApiPattern>> patternGroups,
	                        Map<String, LinkedHashSet<Finding>> grouped) {
		if (node.methods == null) return;
		for (MethodNode mn : node.methods) {
			if (mn.instructions == null) continue;
			String method = mn.name + mn.desc;
			for (AbstractInsnNode insn = mn.instructions.getFirst(); insn != null; insn = insn.getNext()) {
				if (insn instanceof MethodInsnNode mi) {
					String ref = mi.owner + "." + mi.name + mi.desc;
					for (var entry : patternGroups.entrySet())
						for (ApiPattern p : entry.getValue())
							if (p.matchesMethod(mi.owner, mi.name, mi.desc))
								grouped.get(entry.getKey())
										.add(new Finding(entry.getKey(), className, method, "method-call", ref));
				} else if (insn instanceof FieldInsnNode fi) {
					String ref = fi.owner + "." + fi.name;
					for (var entry : patternGroups.entrySet())
						for (ApiPattern p : entry.getValue())
							if (p.matchesField(fi.owner, fi.name))
								grouped.get(entry.getKey())
										.add(new Finding(entry.getKey(), className, method, "field-access", ref));
				} else if (insn instanceof LdcInsnNode ldc) {
					for (var entry : patternGroups.entrySet())
						for (ApiPattern p : entry.getValue())
							if (p.matchesConstant(ldc.cst))
								grouped.get(entry.getKey())
										.add(new Finding(entry.getKey(), className, method, "constant", p.label()));
				}
			}
		}
	}

	private record Finding(String category, String className, String method, String kind, String matched) {}

	private static Set<String> parseSet(String str, String defaults) {
		String source = (str == null || str.isBlank()) ? defaults : str;
		Set<String> result = new LinkedHashSet<>();
		for (String part : source.split(","))
			result.add(part.trim().toLowerCase());
		return result;
	}

	private static Map<String, List<ApiPattern>> buildPatternGroups(Set<String> categories) {
		Map<String, List<ApiPattern>> groups = new LinkedHashMap<>();

		if (categories.contains("networking"))
			groups.put("networking", List.of(
					ownerPrefix("java/net/"),
					ownerPrefix("javax/net/"),
					ownerPrefix("java/rmi/"),
					ownerPrefix("javax/rmi/"),
					ownerPrefix("sun/net/"),
					ownerPrefix("com/sun/corba/se/"),
					method("java/net/URL", "openConnection"),
					method("java/net/URL", "openStream"),
					method("java/net/HttpURLConnection", "connect"),
					ownerPrefix("java/nio/channels/SocketChannel")
			));

		if (categories.contains("file-io"))
			groups.put("file-io", List.of(
					ownerPrefix("java/io/"),
					ownerPrefix("java/nio/"),
					ownerPrefix("sun/nio/"),
					ownerPrefix("java/util/jar/"),
					ownerPrefix("java/util/zip/"),
					ownerPrefix("javax/imageio/ImageIO"),
					method("java/lang/Class", "getResource"),
					method("java/lang/ClassLoader", "getResource"),
					method("java/lang/ClassLoader", "getSystemResource"),
					method("java/io/File", "delete"),
					method("java/io/File", "deleteOnExit"),
					method("java/io/File", "setExecutable"),
					method("java/lang/System", "getProperty"),
					method("java/lang/System", "getenv")
			));

		if (categories.contains("reflection"))
			groups.put("reflection", List.of(
					ownerPrefix("java/lang/reflect/"),
					ownerPrefix("java/lang/invoke/"),
					ownerPrefix("sun/reflect/"),
					method("java/lang/Class", "forName"),
					method("java/lang/Class", "getDeclaredMethod"),
					method("java/lang/Class", "getDeclaredField"),
					method("java/lang/Class", "getDeclaredConstructor"),
					method("java/lang/Class", "getMethod"),
					method("java/lang/Class", "getField"),
					method("java/lang/Class", "getConstructor"),
					method("java/lang/Class", "getClassLoader"),
					method("java/lang/Class", "getAnnotation"),
					method("java/lang/Class", "newInstance"),
					method("java/lang/reflect/Method", "invoke"),
					method("java/lang/reflect/Field", "set"),
					method("java/lang/reflect/Field", "get"),
					method("java/lang/reflect/Constructor", "newInstance"),
					method("java/lang/reflect/AccessibleObject", "setAccessible")
			));

		if (categories.contains("runtime-exec"))
			groups.put("runtime-exec", List.of(
					method("java/lang/Runtime", "exec"),
					method("java/lang/Runtime", "getRuntime"),
					method("java/lang/Runtime", "halt"),
					method("java/lang/Runtime", "addShutdownHook"),
					ownerPrefix("java/lang/Process"),
					method("java/lang/ProcessBuilder", "<init>"),
					method("java/lang/ProcessBuilder", "start"),
					method("java/lang/ProcessBuilder", "command"),
					method("java/lang/System", "exit")
			));

		if (categories.contains("unsafe"))
			groups.put("unsafe", List.of(
					ownerPrefix("sun/misc/Unsafe"),
					ownerPrefix("jdk/internal/misc/Unsafe"),
					method("java/lang/invoke/MethodHandles$Lookup", "defineClass"),
					method("java/lang/invoke/MethodHandles", "privateLookupIn"),
					field("java/lang/System", "security")
			));

		if (categories.contains("native-interop"))
			groups.put("native-interop", List.of(
					ownerPrefix("com/sun/jna/"),
					ownerPrefix("org/jnativehook/"),
					ownerPrefix("jdk/incubator/foreign/"),
					ownerPrefix("java/lang/foreign/"),
					method("java/lang/System", "load"),
					method("java/lang/System", "loadLibrary"),
					method("java/lang/System", "mapLibraryName"),
					method("java/lang/Runtime", "load"),
					method("java/lang/Runtime", "loadLibrary"),
					method("java/awt/Toolkit", "getSystemClipboard"),
					ownerPrefix("java/awt/datatransfer/Clipboard")
			));

		if (categories.contains("classloading"))
			groups.put("classloading", List.of(
					method("java/lang/ClassLoader", "defineClass"),
					method("java/lang/ClassLoader", "loadClass"),
					method("java/lang/ClassLoader", "getSystemClassLoader"),
					method("java/net/URLClassLoader", "<init>"),
					method("java/security/SecureClassLoader", "defineClass"),
					method("java/lang/invoke/MethodHandles$Lookup", "defineClass"),
					method("java/lang/invoke/MethodHandles$Lookup", "defineHiddenClass")
			));

		if (categories.contains("crypto"))
			groups.put("crypto", List.of(
					method("javax/crypto/Cipher", "getInstance"),
					method("javax/crypto/Cipher", "init"),
					method("javax/crypto/Cipher", "doFinal"),
					method("java/security/MessageDigest", "getInstance"),
					ownerPrefix("javax/crypto/spec/"),
					ownerPrefix("java/security/spec/"),
					method("java/util/Base64$Decoder", "decode"),
					method("java/util/Base64$Encoder", "encode"),
					method("java/util/Base64", "getDecoder"),
					method("java/util/Base64", "getEncoder")
			));

		if (categories.contains("instrumentation"))
			groups.put("instrumentation", List.of(
					ownerPrefix("java/lang/instrument/"),
					ownerPrefix("sun/instrument/"),
					ownerPrefix("sun/tools/attach/")
			));

		if (categories.contains("management"))
			groups.put("management", List.of(
					ownerPrefix("java/lang/management/"),
					ownerPrefix("javax/management/")
			));

		if (categories.contains("registry"))
			groups.put("registry", List.of(
					ownerPrefix("java/util/prefs/Preferences"),
					ownerPrefix("com/registry/"),
					intConst("HKCR", 0x80000000),
					intConst("HKCU", 0x80000001),
					intConst("HKLM", 0x80000002),
					intConst("HKU", 0x80000003),
					intConst("HKCC", 0x80000005),
					intConst("KEY_READ", 0x20019),
					intConst("KEY_WRITE", 0x20006),
					intConst("SC_MANAGER_ALL_ACCESS", 0xF003F),
					intConst("SERVICE_ALL_ACCESS", 0xF01FF)
			));

		return groups;
	}

	private static ApiPattern method(String owner, String name) {
		return new ApiPattern(owner, name, false, false, null, null);
	}

	private static ApiPattern ownerPrefix(String prefix) {
		return new ApiPattern(prefix, null, true, false, null, null);
	}

	private static ApiPattern field(String owner, String name) {
		return new ApiPattern(owner, name, false, true, null, null);
	}

	private static ApiPattern intConst(String label, int value) {
		return new ApiPattern(null, null, false, false, label, value);
	}

	private record ApiPattern(String owner, String name, boolean prefix, boolean fieldOnly,
	                           String constLabel, Integer constValue) {
		boolean matchesMethod(String mOwner, String mName, String mDesc) {
			if (constValue != null) return false;
			if (fieldOnly) return false;
			if (prefix) return mOwner.startsWith(owner);
			if (!mOwner.equals(owner)) return false;
			return name == null || mName.equals(name);
		}

		boolean matchesField(String fOwner, String fName) {
			if (constValue != null) return false;
			if (prefix) return fOwner.startsWith(owner);
			if (!fieldOnly) return false;
			return fOwner.equals(owner) && (name == null || fName.equals(name));
		}

		boolean matchesConstant(Object cst) {
			if (constValue == null) return false;
			if (cst instanceof Integer i) return i.equals(constValue);
			return false;
		}

		String label() {
			if (constLabel != null) return "const:" + constLabel + "=0x" + Integer.toHexString(constValue);
			return owner + (name != null ? "." + name : ".*");
		}
	}
}
